// D:\lckgm\src\utils\simulationEngine.js

// 1. ë°ì´í„° Import (ìƒëŒ€ ê²½ë¡œ ë°˜ì˜)
// src/utils ì—ì„œ src/data ë¡œ ê°€ê¸° ìœ„í•´ '../data' ì‚¬ìš©
import allMasteryRaw from '../data/player_mastery/index'; // index.jsëŠ” í´ë”ëª…ë§Œ ì¨ë„ ìë™ìœ¼ë¡œ ì¸ì‹ë¨
import championList from '../data/champions.json';

// ë§Œì•½ gameRules.jsê°€ src/utilsì— ìˆë‹¤ë©´:
import { GAME_CONSTANTS } from './gameRules'; 

// ==========================================
// 2. ë°ì´í„° ì „ì²˜ë¦¬ (Data Pre-processing)
// ==========================================
// ë°°ì—´ í˜•íƒœì˜ ìˆ™ë ¨ë„ ë°ì´í„°ë¥¼ { "PlayerID": { ... } } í˜•íƒœì˜ ë§µìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ê²€ìƒ‰ ì†ë„ í–¥ìƒ
const MASTERY_MAP = allMasteryRaw.reduce((acc, player) => {
  // player_mastery json íŒŒì¼ë“¤ì˜ id í•„ë“œ ("Clear", "Faker" ë“±)ë¥¼ í‚¤ë¡œ ì‚¬ìš©
  if (player.id) {
    acc[player.id] = player;
  }
  return acc;
}, {});

// ==========================================
// 3. ì‹œë®¬ë ˆì´ì…˜ ì„¤ì •ê°’ (Settings)
// ==========================================
const SIM_CONSTANTS = {
  // ê°€ì¤‘ì¹˜ (Total 1.0) - [55:25:20] ë¹„ìœ¨
  WEIGHTS: {
    STATS: 0.55,    // ì„ ìˆ˜ ê¸°ë³¸ ëŠ¥ë ¥ì¹˜ (players.json)
    META: 0.25,     // ì±”í”¼ì–¸ í‹°ì–´ (champions.json)
    MASTERY: 0.20   // ìˆ™ë ¨ë„ (player_mastery)
  },
  // ë©”íƒ€ ê³„ìˆ˜ ( 5í‹°ì–´ ì²´ê³„)
  META_COEFF: {
    STANDARD: { 1: 1.0, 2: 0.95, 3: 0.90, 4: 0.85, 5: 0.80 },
   
  // ìˆ™ë ¨ë„ ë³´ì • ë³€ìˆ˜
  LOW_SAMPLE_THRESHOLD: 5,    // ê²½ê¸° ìˆ˜ 5íšŒ ì´í•˜ì¼ ë•Œ ë°ì´í„° ì‹ ë¢°ë„ ë‚®ìŒ
  OTP_SCORE_THRESHOLD: 80,    // ìˆ™ë ¨ë„ ì ìˆ˜ 80 ì´ìƒì´ë©´ 'ì¥ì¸'ìœ¼ë¡œ ì¸ì •
  OTP_TIER_BOOST: 2,          // ì¥ì¸ì¼ ë•Œ ì±”í”¼ì–¸ í‹°ì–´ ë³´ì • (ì˜ˆ: 4í‹°ì–´ -> 2í‹°ì–´ íš¨ìœ¨)
  VAR_RANGE: 0.12             // ê²½ê¸° ë‹¹ ëœë¤ ë³€ìˆ˜ (Â±12%)
};

// ==========================================
// 4. ë©”ì¸ í•¨ìˆ˜ (Main Function)
// ==========================================
export function simulateMatch(teamA, teamB) {
  const log = [];
  let scoreA = 0;
  let scoreB = 0;

  // 1. ë“œë˜ê³¤ ì†ì„± ê²°ì • (ëœë¤)
  const dragonType = GAME_CONSTANTS.DRAGONS.TYPES[Math.floor(Math.random() * GAME_CONSTANTS.DRAGONS.TYPES.length)];
  const dragonBuff = GAME_CONSTANTS.DRAGONS.BUFFS[dragonType];
  
  // 2. ë°´í”½ (Draft Phase) - ì„ ìˆ˜ë³„ ìµœì  ì±”í”¼ì–¸ ì„ íƒ
  const picksA = draftTeam(teamA.roster);
  const picksB = draftTeam(teamB.roster);

  log.push(`ğŸ“¢ [ê²½ê¸° ì‹œì‘] ${teamA.name} vs ${teamB.name}`);
  log.push(`ğŸ‰ ì „ì¥: ${dragonType} ë“œë˜ê³¤ í˜‘ê³¡ (${dragonBuff.description})`);
  log.push(`âœ¨ Key Matchup: ${picksA[2].champName}(${teamA.roster[2].id}) vs ${picksB[2].champName}(${teamB.roster[2].id})`);

  // 3. ì‹œë®¬ë ˆì´ì…˜ (Phase 1~3)
  
  // Phase 1: EARLY (ë¼ì¸ì „)
  const p1 = calculatePhase('EARLY', teamA, teamB, picksA, picksB, null, 1.0);
  scoreA += p1.scoreA; scoreB += p1.scoreB;
  log.push(p1.log);

  // Phase 2: MID (ìš´ì˜) - ì´ˆë°˜ ìŠ¹ìì—ê²Œ ìŠ¤ë…¸ìš°ë³¼ ë³´ë„ˆìŠ¤(1.1ë°°)
  const midBonusTeam = p1.scoreA > p1.scoreB ? 'A' : 'B';
  const p2 = calculatePhase('MID', teamA, teamB, picksA, picksB, midBonusTeam, 1.1);
  scoreA += p2.scoreA; scoreB += p2.scoreB;
  log.push(p2.log);

  // Phase 3: LATE (í•œíƒ€) - ì¤‘ë°˜ ìŠ¹ìì—ê²Œ ì˜¤ë¸Œì íŠ¸ ë²„í”„(1.15ë°°)
  const lateBonusTeam = p2.scoreA > p2.scoreB ? 'A' : 'B';
  const p3 = calculatePhase('LATE', teamA, teamB, picksA, picksB, lateBonusTeam, 1.15);
  scoreA += p3.scoreA; scoreB += p3.scoreB;
  log.push(p3.log);

  // 4. ê²°ê³¼ ë°˜í™˜
  const winner = scoreA > scoreB ? teamA : teamB;
  const loser = scoreA > scoreB ? teamB : teamA;

  return {
    winner: winner.name,
    loser: loser.name,
    scoreA: Math.round(scoreA),
    scoreB: Math.round(scoreB),
    logs: log,
    picks: { A: picksA, B: picksB } // ê²°ê³¼ì°½ì—ì„œ í”½ ì •ë³´ë¥¼ ë³´ì—¬ì¤„ ë•Œ ì‚¬ìš©
  };
}

// ==========================================
// 5. í•µì‹¬ ë¡œì§ (Core Logic)
// ==========================================

/**
 * ğŸ•µï¸â€â™‚ï¸ ê°€ìƒ ë°´í”½ (Draft System)
 * ì„ ìˆ˜ì˜ 'ìˆ™ë ¨ë„ ë°ì´í„°(pool)'ì™€ 'í˜„ì¬ ë©”íƒ€(champions.json)'ë¥¼ ì¡°í•©í•´ ì±”í”¼ì–¸ ì„ íƒ
 */
function draftTeam(roster) {
  return roster.map(player => {
    // A. í˜„ì¬ ë©”íƒ€ ì±”í”¼ì–¸ (1~2í‹°ì–´) ì¶”ì¶œ
    const metaPool = championList.filter(c => c.role === player.í¬ì§€ì…˜ && c.tier <= 2);
    
    // B. ì„ ìˆ˜ ìˆ™ë ¨ë„ ë°ì´í„° í™•ì¸
    // MASTERY_MAPì—ì„œ í•´ë‹¹ ì„ ìˆ˜ IDë¡œ ë°ì´í„°ë¥¼ ì°¾ìŒ
    const playerData = MASTERY_MAP[player.id];
    let masteryPool = [];
    
    if (playerData && playerData.pool) {
      // 2025 ì‹œì¦Œ ëª¨ìŠ¤íŠ¸ì™€ ì»¤ë¦¬ì–´ ëª¨ìŠ¤íŠ¸ë¥¼ ì„ìŒ
      const seasonPicks = playerData.pool.filter(p => p.category === 'Season 2025').slice(0, 3);
      const careerPicks = playerData.pool.filter(p => p.category === 'Career').slice(0, 3);
      masteryPool = [...seasonPicks, ...careerPicks];
    }

    // C. í”½ ê²°ì • ë¡œì§
    let finalPick = null;
    
    // 70% í™•ë¥ ë¡œ ë³¸ì¸ì˜ 'ìˆ™ë ¨ë„ ì±”í”¼ì–¸' ì„ íƒ (ë°ì´í„°ê°€ ìˆì„ ê²½ìš°)
    if (masteryPool.length > 0 && Math.random() < 0.7) {
      const selectedMastery = masteryPool[Math.floor(Math.random() * masteryPool.length)];
      // ì„ íƒëœ ì±”í”¼ì–¸ì˜ ê¸°ë³¸ ì •ë³´(í‹°ì–´ ë“±)ë¥¼ champions.jsonì—ì„œ ì°¾ìŒ
      const champInfo = championList.find(c => c.name === selectedMastery.name) || { name: selectedMastery.name, tier: 3 };
      finalPick = { ...champInfo, mastery: selectedMastery };
    } else {
      // 30% í™•ë¥  í˜¹ì€ ìˆ™ë ¨ë„ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ 'ë©”íƒ€ ì±”í”¼ì–¸' ì„ íƒ
      const selectedMeta = metaPool[Math.floor(Math.random() * metaPool.length)] || { name: "Unknown", tier: 3 };
      
      // ë©”íƒ€ í”½ì´ë¼ë„ ë³¸ì¸ ìˆ™ë ¨ë„ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸
      let masteryInfo = null;
      if (playerData && playerData.pool) {
        masteryInfo = playerData.pool.find(p => p.name === selectedMeta.name);
      }
      finalPick = { ...selectedMeta, mastery: masteryInfo };
    }

    return {
      champName: finalPick.name,
      tier: finalPick.tier || 3,
      mastery: finalPick.mastery // { games, winRate, kda } or null
    };
  });
}

/**
 * âš”ï¸ í˜ì´ì¦ˆ ê³„ì‚° (Calculation)
 */
function calculatePhase(phase, tA, tB, picksA, picksB, bonusTeam, bonusVal) {
  let powerA = 0;
  let powerB = 0;

  for (let i = 0; i < 5; i++) {
    const pA = tA.roster[i];
    const pB = tB.roster[i];
    const pickA = picksA[i];
    const pickB = picksB[i];

    // 1. [ëŠ¥ë ¥ì¹˜] (55%) - players.jsonì˜ ìƒì„¸ ìŠ¤íƒ¯
    let statA = getPhaseStat(phase, pA);
    let statB = getPhaseStat(phase, pB);

    // *ì›ë”œ íŠ¹ìˆ˜ ë¡œì§*: ì„œí¬í„°(ì¸ë±ìŠ¤ 4) ëŠ¥ë ¥ì¹˜ 30% í¡ìˆ˜
    if (pA.í¬ì§€ì…˜ === 'ADC') statA += getPhaseStat(phase, tA.roster[4]) * 0.3;
    if (pB.í¬ì§€ì…˜ === 'ADC') statB += getPhaseStat(phase, tB.roster[4]) * 0.3;

    // *í¬ì§€ì…˜ í€˜ìŠ¤íŠ¸ ë³´ë„ˆìŠ¤* (gameRules.js ì—°ë™)
    if (phase === 'LATE') {
      if (pA.í¬ì§€ì…˜ === 'TOP') statA *= GAME_CONSTANTS.ROLE_QUEST_BONUS.TOP.effect.splitPushPower;
      if (pB.í¬ì§€ì…˜ === 'TOP') statB *= GAME_CONSTANTS.ROLE_QUEST_BONUS.TOP.effect.splitPushPower;
      if (pA.í¬ì§€ì…˜ === 'ADC') statA *= GAME_CONSTANTS.ROLE_QUEST_BONUS.ADC.effect.damageMultiplier;
      if (pB.í¬ì§€ì…˜ === 'ADC') statB *= GAME_CONSTANTS.ROLE_QUEST_BONUS.ADC.effect.damageMultiplier;
    } else if (phase === 'MID') {
      if (pA.í¬ì§€ì…˜ === 'MID') statA *= GAME_CONSTANTS.ROLE_QUEST_BONUS.MID.effect.roamingSpeed;
      if (pB.í¬ì§€ì…˜ === 'MID') statB *= GAME_CONSTANTS.ROLE_QUEST_BONUS.MID.effect.roamingSpeed;
    }

    // 2. [ìˆ™ë ¨ë„] (20%) - player_mastery ë°ì´í„°
    const mastA = calculateMasteryScore(pA, pickA.mastery);
    const mastB = calculateMasteryScore(pB, pickB.mastery);

    // 3. [ë©”íƒ€] (25%) - ì±”í”¼ì–¸ í‹°ì–´ + ì¥ì¸ ë³´ì •
    const metaA = getMetaScore(pA.í¬ì§€ì…˜, pickA.tier, mastA);
    const metaB = getMetaScore(pB.í¬ì§€ì…˜, pickB.tier, mastB);

    // [ìµœì¢… ì ìˆ˜ í•©ì‚°]
    const scoreA = (statA * SIM_CONSTANTS.WEIGHTS.STATS) +
                   (mastA * SIM_CONSTANTS.WEIGHTS.MASTERY) +
                   (metaA * SIM_CONSTANTS.WEIGHTS.META);

    const scoreB = (statB * SIM_CONSTANTS.WEIGHTS.STATS) +
                   (mastB * SIM_CONSTANTS.WEIGHTS.MASTERY) +
                   (metaB * SIM_CONSTANTS.WEIGHTS.META);

    // [ëœë¤ ë³€ìˆ˜] (ì»¨ë””ì…˜ Â±12%)
    powerA += scoreA * (1 + (Math.random() * SIM_CONSTANTS.VAR_RANGE * 2 - SIM_CONSTANTS.VAR_RANGE));
    powerB += scoreB * (1 + (Math.random() * SIM_CONSTANTS.VAR_RANGE * 2 - SIM_CONSTANTS.VAR_RANGE));
  }

  // [íŒ€ ë³´ë„ˆìŠ¤ ì ìš©]
  if (bonusTeam === 'A') powerA *= bonusVal;
  if (bonusTeam === 'B') powerB *= bonusVal;

  return {
    scoreA: powerA,
    scoreB: powerB,
    log: generateLog(phase, powerA, powerB, tA.name, tB.name)
  };
}

// --- Helper Functions ---

function getPhaseStat(phase, player) {
  const s = player.ìƒì„¸;
  // í˜ì´ì¦ˆë³„ ê°€ì¤‘ì¹˜ (ë¼ì¸ì „/ìš´ì˜/í•œíƒ€)
  if (phase === 'EARLY') return (s.ë¼ì¸ì „ * 0.6) + (s.ë¬´ë ¥ * 0.4);
  if (phase === 'MID') return (s.ìš´ì˜ * 0.5) + (s.ì„±ì¥ * 0.3) + (s.í•œíƒ€ * 0.2);
  return (s.í•œíƒ€ * 0.5) + (s.ë¬´ë ¥ * 0.3) + (s.ì•ˆì •ì„± * 0.2);
}

// ìˆ™ë ¨ë„ ì ìˆ˜ ê³„ì‚° (ë¡œê·¸ í•¨ìˆ˜ ê°€ì¤‘ì¹˜ ì ìš©)
function calculateMasteryScore(player, masteryData) {
  // ë°ì´í„°ê°€ ì—†ìœ¼ë©´(ì—°ìŠµìš© í”½) ê¸°ë³¸ OVRì˜ 80%ë§Œ ë°˜ì˜
  if (!masteryData) return player.ì¢…í•© * 0.8;

  const { games, winRate, kda } = masteryData;
  
  // ì ìˆ˜ í™˜ì‚° ê³µì‹: (ìŠ¹ë¥  * 0.5) + (KDA * 10) + ê¸°ë³¸ì  20
  // ì˜ˆ: ìŠ¹ë¥  50% + KDA 3.0 = 25 + 30 + 20 = 75ì 
  let baseScore = (winRate * 0.5) + (kda * 10) + 20;
  
  // íŒìˆ˜ ë³´ë„ˆìŠ¤: ë¡œê·¸ í•¨ìˆ˜ (ë§ì´ í• ìˆ˜ë¡ ì ìˆ˜ê°€ ì˜¤ë¥´ì§€ë§Œ ìƒìŠ¹í­ì€ ì¤„ì–´ë“¦)
  // 10íŒ: +5ì , 100íŒ: +10ì  ì •ë„
  const volumeBonus = Math.log10(games + 1) * 5;

  return Math.min(100, baseScore + volumeBonus);
}

// ë©”íƒ€ ì ìˆ˜ ê³„ì‚° (ì¥ì¸ ë³´ì • í¬í•¨)
function getMetaScore(position, tier, masteryScore) {
  let finalTier = tier;

  // ì¥ì¸ ë³´ì •: ìˆ™ë ¨ë„ 80ì  ì´ìƒì´ë©´ í‹°ì–´ë¥¼ 2ë‹¨ê³„ ë†’ê²Œ ì³ì¤Œ (4í‹°ì–´ -> 2í‹°ì–´ ì„±ëŠ¥)
  if (masteryScore >= SIM_CONSTANTS.OTP_SCORE_THRESHOLD) {
    finalTier = Math.max(1, tier - SIM_CONSTANTS.OTP_TIER_BOOST);
  }

  let coeff = 1.0;
  if (position === 'ADC') {
    // ì›ë”œ 3í‹°ì–´ ì²´ê³„
    const t = Math.max(1, Math.min(3, finalTier));
    coeff = SIM_CONSTANTS.META_COEFF.ADC[t];
  } else {
    // ì¼ë°˜ 5í‹°ì–´ ì²´ê³„
    const t = Math.max(1, Math.min(5, finalTier));
    coeff = SIM_CONSTANTS.META_COEFF.STANDARD[t];
  }

  return 100 * coeff;
}

function generateLog(phase, sA, sB, nA, nB) {
  const diff = sA - sB;
  const leader = diff > 0 ? nA : nB;
  
  if (phase === 'EARLY') {
    return diff > 0 ? `âš”ï¸ [ì´ˆë°˜] ${leader}, ê°•ë ¥í•œ ë¼ì¸ì „ìœ¼ë¡œ ì£¼ë„ê¶Œì„ ì¡ìŠµë‹ˆë‹¤.` : `âš”ï¸ [ì´ˆë°˜] ${leader} ì •ê¸€ëŸ¬ì˜ ê°±í‚¹ì´ ì ì¤‘í–ˆìŠµë‹ˆë‹¤.`;
  } else if (phase === 'MID') {
    return diff > 0 ? `ğŸ—ºï¸ [ì¤‘ë°˜] ${leader}, ìš´ì˜ ë‹¨ê³„ì—ì„œ ìƒëŒ€ë¥¼ ì••ë„í•©ë‹ˆë‹¤.` : `ğŸ—ºï¸ [ì¤‘ë°˜] ${leader}, ì˜ë¼ë¨¹ê¸° í”Œë ˆì´ë¡œ ì´ë“ì„ ë´…ë‹ˆë‹¤.`;
  } else {
    return diff > 0 ? `ğŸ’¥ [í›„ë°˜] ${leader}, í•œíƒ€ ëŒ€ìŠ¹! ë„¥ì„œìŠ¤ë¥¼ íŒŒê´´í•©ë‹ˆë‹¤.` : `ğŸ’¥ [í›„ë°˜] ${leader}ì˜ ê¸°ì ì ì¸ ì—­ì „ìŠ¹!`;
  }
}